[
  {
    "objectID": "regions.html",
    "href": "regions.html",
    "title": "Regions",
    "section": "",
    "text": "A region is the open set on one side of a closed curve or closed path.",
    "crumbs": [
      "Home",
      "Regions"
    ]
  },
  {
    "objectID": "regions.html#simply-connected",
    "href": "regions.html#simply-connected",
    "title": "Regions",
    "section": "Simply connected",
    "text": "Simply connected\nA simply connected region is one bounded by a single closed curve or path; topologically, it has no holes. The Interior1CRegion and Exterior1CRegion types represent the interior and exterior of such a boundary, respectively. The preferred method for constructing a value of one of these types is to use interior or exterior with a closed curve or path as argument. If the given curve is bounded, these constructors ignore its orientation and select the bounded or unbounded region it defines, respectively. For an unbounded boundary curve, points “to the left” of it are considered the interior.\nThere are also methods to facilitate construction of important common regions. For disks there are\n\ndisk(C) for a Circle C\ndisk(center, radius)\nunitdisk\n\nFor half-planes there are\n\nhalfplane(L) for a Line L\nupperhalfplane, lowerhalfplane, lefthalfplane, righthalfplane",
    "crumbs": [
      "Home",
      "Regions"
    ]
  },
  {
    "objectID": "regions.html#multiply-connected",
    "href": "regions.html#multiply-connected",
    "title": "Regions",
    "section": "Multiply connected",
    "text": "Multiply connected\nThe ExteriorRegion class represents a region that is exterior to several closed curves or paths, which are given as an array of such objects.\nThe InteriorRegion class represents a region that is interior to one outer closed curve or path and exterior to several inner closed curves or paths, which are given as an array of such objects. The particular case of a doubly connected region can be constructed by between(outer, inner), giving the two boundary components. The given orientation is ignored for any bounded component.\n\nAnnulus\nAn Annulus is the doubly connected region between two concentric circles. Construction is by Annulus(outer, inner), where Circle values are given explicitly, or by Annulus(outrad, inrad, center=0), giving the radii and optionally the center.",
    "crumbs": [
      "Home",
      "Regions"
    ]
  },
  {
    "objectID": "regions.html#methods",
    "href": "regions.html#methods",
    "title": "Regions",
    "section": "Methods",
    "text": "Methods\nHere R is a Region subtype and z is a number.\n\n\n\nMethod\nDescription\n\n\n\n\nR.boundary()\nBoundary curve(s)/path(s) of a region.\n\n\nR.contains(z)\nDetermine whether z is in R.\n\n\nR.isfinite()\nDetermine whether the region is bounded.\n\n\n\nDefault implementations are provided for +, -, *, /, performing translation, rotation, and scaling.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nR.outerboundary()\nCurve/path of the outermost boundary, if it exists.\n\n\nR.innerboundary()\nCurve(s)/path(s) of inner boundaries (that R is exterior to).",
    "crumbs": [
      "Home",
      "Regions"
    ]
  },
  {
    "objectID": "regions.html#examples",
    "href": "regions.html#examples",
    "title": "Regions",
    "section": "Examples",
    "text": "Examples\n\nfrom cxregions import *\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nDetected IPython. Loading juliacall extension. See https://juliapy.github.io/PythonCall.jl/stable/compat/#IPython\n\n\nHere is a “dog bone” region.\n\na = Arc(-1, 1, -1j)\nright = Path([4 + 1j + a, 4 - 1j - 1j * a])\ns = Segment(-3 + 1j, 3 + 1j)\np = ClosedPath([s, *right, -s, *(-right)])\nr = interior(np.exp(1j * np.pi / 4) * p)\nprint(r.boundary.arclength())\n\n30.84955592153876\n\n\nA multiply-connected exterior region:\nc = Circle(0, 1) t = n_gon(3) s = n_gon(4) exterior_region = ExteriorRegion([c, 3 + s, 6 + t]) print(exterior_region)",
    "crumbs": [
      "Home",
      "Regions"
    ]
  },
  {
    "objectID": "reference/paths.html",
    "href": "reference/paths.html",
    "title": "paths",
    "section": "",
    "text": "paths\nPath classes for the cxregions package.\nThis module contains all path-related classes including the base JuliaPath class and specific path types like Polygon, CircularPolygon, and Rectangle.\n\n\n\n\n\nName\nDescription\n\n\n\n\nCircularPolygon\nA polygon with circular arc sides.\n\n\nClosedPath\nA closed path that forms a Jordan curve.\n\n\nJuliaPath\nBase class for wrapping Julia path objects from ComplexRegions.jl.\n\n\nPath\nA path composed of connected curves.\n\n\nPolygon\nA polygon with straight sides.\n\n\nRectangle\nA rectangular polygon.\n\n\n\n\n\npaths.CircularPolygon(arg)\nA polygon with circular arc sides.\nThis class represents a polygon where each side can be either a straight line segment or a circular arc.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narg\nlist of curves or juliacall.AnyValue\nList of curves (segments and arcs) that form the polygon sides, or Julia CircularPolygon object to wrap\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\npath\nClosedPath\nThe underlying closed path\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Arc, Segment\n&gt;&gt;&gt; arc1 = Arc(1, 2 + 1j, 1j)\n&gt;&gt;&gt; seg1 = Segment(1j, -1)\n&gt;&gt;&gt; arc2 = Arc(-1, -0.5j, -1j)\n&gt;&gt;&gt; seg2 = Segment(-1j, 1)\n&gt;&gt;&gt; cpoly = CircularPolygon([arc1, seg1, arc2, seg2])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nside\nGet the k-th side of the polygon.\n\n\nsides\nGet all sides of the polygon.\n\n\n\n\n\npaths.CircularPolygon.side(k)\nGet the k-th side of the polygon.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the side\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nThe k-th side of the polygon\n\n\n\n\n\n\n\npaths.CircularPolygon.sides()\nGet all sides of the polygon.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist of JuliaCurve\nList of curves that form the polygon sides\n\n\n\n\n\n\n\n\n\npaths.ClosedPath(curves)\nA closed path that forms a Jordan curve.\nThis class represents a closed sequence of curves that form a continuous closed path, enabling computation of winding numbers and containment tests.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurves\nlist of JuliaCurve, Path, or juliacall.AnyValue\nList of curves that form the closed path, or Julia ClosedPath object to wrap\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Segment\n&gt;&gt;&gt; seg1 = Segment(0, 1)\n&gt;&gt;&gt; seg2 = Segment(1, 1+1j)\n&gt;&gt;&gt; seg3 = Segment(1+1j, 1j)\n&gt;&gt;&gt; seg4 = Segment(1j, 0)\n&gt;&gt;&gt; closed_path = ClosedPath([seg1, seg2, seg3, seg4])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisinside\nCheck if point z is inside the closed path.\n\n\nwinding\nCompute the winding number around point z.\n\n\n\n\n\npaths.ClosedPath.isinside(z)\nCheck if point z is inside the closed path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is inside the path, False otherwise\n\n\n\n\n\n\n\npaths.ClosedPath.winding(z)\nCompute the winding number around point z.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint around which to compute winding number\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nWinding number (positive for counterclockwise orientation)\n\n\n\n\n\n\n\n\n\npaths.JuliaPath(julia_obj)\nBase class for wrapping Julia path objects from ComplexRegions.jl.\nThis class provides a Python interface to Julia path objects, which are sequences of connected curves forming a continuous path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njulia_obj\njuliacall.AnyValue\nA Julia path object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\njulia\njuliacall.AnyValue\nThe underlying Julia path object\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nangles\nGet the turning angles at all vertices.\n\n\narclength\nCompute the total arc length of the path.\n\n\narg\nFind the parameter value corresponding to point z on the path.\n\n\nclosest\nFind the closest point on the path to z.\n\n\nconj\nReturn the complex conjugate of the path.\n\n\ncurve\nGet the k-th curve in the path.\n\n\ncurves\nGet all curves that make up the path.\n\n\ndist\nCompute the distance from point z to the path.\n\n\nget\nGet a field from the underlying Julia object.\n\n\nintersect\nFind intersection points with another path.\n\n\ninv\nCompute the inversion of the path with respect to the unit circle.\n\n\nisapprox\nCheck if this path is approximately equal to another.\n\n\nisfinite\nCheck if the path has finite length.\n\n\nispositive\nCheck if the path has positive orientation.\n\n\nisreal\nCheck if the path lies on the real axis.\n\n\nlength\nGet the number of curves in the path.\n\n\nnormal\nCompute the normal vector at parameter t.\n\n\npoint\nEvaluate the path at parameter value t.\n\n\nreflect\nReflect point z across the path.\n\n\nreverse\nReturn the path with reversed orientation.\n\n\ntangent\nCompute the tangent vector at parameter t.\n\n\nunittangent\nCompute the unit tangent vector at parameter t.\n\n\nvertex\nGet the k-th vertex of the path.\n\n\nvertices\nGet all vertices of the path.\n\n\n\n\n\npaths.JuliaPath.angles()\nGet the turning angles at all vertices.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray\nArray of turning angles at vertices\n\n\n\n\n\n\n\npaths.JuliaPath.arclength()\nCompute the total arc length of the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTotal arc length of all curves in the path\n\n\n\n\n\n\n\npaths.JuliaPath.arg(z)\nFind the parameter value corresponding to point z on the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to locate on the path\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat or None\nParameter value if z is on the path, None otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.closest(z)\nFind the closest point on the path to z.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nClosest point on the path to z\n\n\n\n\n\n\n\npaths.JuliaPath.conj()\nReturn the complex conjugate of the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath\nComplex conjugate of this path\n\n\n\n\n\n\n\npaths.JuliaPath.curve(k)\nGet the k-th curve in the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the curve (0-based)\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nThe k-th curve in the path\n\n\n\n\n\n\n\npaths.JuliaPath.curves()\nGet all curves that make up the path.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist of JuliaCurve\nList of curve objects that form the path\n\n\n\n\n\n\n\npaths.JuliaPath.dist(z)\nCompute the distance from point z to the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDistance from z to the closest point on the path\n\n\n\n\n\n\n\npaths.JuliaPath.get(field)\nGet a field from the underlying Julia object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfield\nstr\nName of the field to retrieve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe value of the requested field\n\n\n\n\n\n\n\npaths.JuliaPath.intersect(other)\nFind intersection points with another path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaPath\nAnother path to intersect with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray or other\nArray of intersection points or other result\n\n\n\n\n\n\n\npaths.JuliaPath.inv()\nCompute the inversion of the path with respect to the unit circle.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath\nInverted path\n\n\n\n\n\n\n\npaths.JuliaPath.isapprox(other)\nCheck if this path is approximately equal to another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaPath\nAnother path to compare with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if paths are approximately equal, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.isfinite()\nCheck if the path has finite length.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the path is finite, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.ispositive()\nCheck if the path has positive orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if positively oriented, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.isreal()\nCheck if the path lies on the real axis.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the path is real, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.length()\nGet the number of curves in the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nNumber of curves in the path\n\n\n\n\n\n\n\npaths.JuliaPath.normal(t=0.0)\nCompute the normal vector at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nNormal vector at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.point(t)\nEvaluate the path at parameter value t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, typically in [0, 1]\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nPoint on the path at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.reflect(z)\nReflect point z across the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to reflect\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nReflected point\n\n\n\n\n\n\n\npaths.JuliaPath.reverse()\nReturn the path with reversed orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath\nPath with reversed orientation\n\n\n\n\n\n\n\npaths.JuliaPath.tangent(t=0.0)\nCompute the tangent vector at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nTangent vector at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.unittangent(t=0.0)\nCompute the unit tangent vector at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nUnit tangent vector at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.vertex(k)\nGet the k-th vertex of the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the vertex\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nCoordinates of the k-th vertex\n\n\n\n\n\n\n\npaths.JuliaPath.vertices()\nGet all vertices of the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray\nArray of vertex coordinates\n\n\n\n\n\n\n\n\n\npaths.Path(curves)\nA path composed of connected curves.\nThis class represents a sequence of curves that form a continuous path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurves\nlist of JuliaCurve or juliacall.AnyValue\nList of curves that form the path, or Julia Path object to wrap\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Segment\n&gt;&gt;&gt; seg1 = Segment(0, 1)\n&gt;&gt;&gt; seg2 = Segment(1, 1+1j)\n&gt;&gt;&gt; path = Path([seg1, seg2])\n\n\n\n\npaths.Polygon(arg)\nA polygon with straight sides.\nThis class represents a polygon where all sides are straight line segments.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narg\nlist of complex or juliacall.AnyValue\nList of vertex coordinates or Julia Polygon object to wrap\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\npath\nClosedPath\nThe underlying closed path\n\n\n\n\n\n\n&gt;&gt;&gt; # Unit square\n&gt;&gt;&gt; poly = Polygon([0, 1, 1+1j, 1j])\n&gt;&gt;&gt; # More complex polygon\n&gt;&gt;&gt; poly2 = Polygon([4, 4 + 3j, 3j, -2j, 6 - 2j, 6])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nside\nGet the k-th side of the polygon.\n\n\nsides\nGet all sides of the polygon.\n\n\n\n\n\npaths.Polygon.side(k)\nGet the k-th side of the polygon.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the side\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nThe k-th side of the polygon\n\n\n\n\n\n\n\npaths.Polygon.sides()\nGet all sides of the polygon.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist of JuliaCurve\nList of line segments that form the polygon sides\n\n\n\n\n\n\n\n\n\npaths.Rectangle(a, b=None)\nA rectangular polygon.\nThis class represents a rectangle, which is a special case of a polygon with four sides at right angles.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex, list, or juliacall.AnyValue\nCenter point, list of vertices, or Julia Rectangle object to wrap\nrequired\n\n\nb\narray - like or complex\nRadii array (if a is center) or opposite corner (if a is corner)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncenter\ncomplex\nCenter of the rectangle\n\n\nradii\narray - like\nHalf-widths in x and y directions\n\n\nrotation\nfloat\nRotation angle of the rectangle\n\n\npolygon\nPolygon\nThe underlying polygon representation\n\n\n\n\n\n\n&gt;&gt;&gt; # Rectangle from center and radii\n&gt;&gt;&gt; rect1 = Rectangle(0+0j, np.array([1.0, 0.5]))\n&gt;&gt;&gt; # Rectangle from opposite corners\n&gt;&gt;&gt; rect2 = Rectangle(-1-1j, 1+1j)\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_julia\nExtract the Julia object from a Python wrapper.\n\n\nn_gon\nConstruct a regular n-gon as a Polygon object.\n\n\nquad\nConstruct a quadrilateral region from a Rectangle.\n\n\nwrap_jl_path\nWrap a Julia path object in the appropriate Python class.\n\n\n\n\n\npaths.get_julia(p)\nExtract the Julia object from a Python wrapper.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\nJuliaCurve, JuliaPath, or other\nPython wrapper object or raw Julia object\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njuliacall.AnyValue or other\nThe underlying Julia object, or the input if not a wrapper\n\n\n\n\n\n\n\npaths.n_gon(n)\nConstruct a regular n-gon as a Polygon object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nPolygon\nRegular n-sided polygon centered at origin with unit circumradius\n\n\n\n\n\n\n&gt;&gt;&gt; # Regular hexagon\n&gt;&gt;&gt; hex_poly = n_gon(6)\n&gt;&gt;&gt; # Regular triangle\n&gt;&gt;&gt; triangle = n_gon(3)\n\n\n\n\npaths.quad(rect)\nConstruct a quadrilateral region from a Rectangle.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrect\nRectangle\nRectangle to convert to a region\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nInterior region of the rectangle\n\n\n\n\n\n\n&gt;&gt;&gt; rect = Rectangle(0+0j, np.array([1.0, 0.5]))\n&gt;&gt;&gt; region = quad(rect)\n\n\n\n\npaths.wrap_jl_path(jul)\nWrap a Julia path object in the appropriate Python class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njul\njuliacall.AnyValue\nA Julia path object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nPath\nThe appropriate Python path wrapper\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a Julia object or not a recognized path type"
  },
  {
    "objectID": "reference/paths.html#classes",
    "href": "reference/paths.html#classes",
    "title": "paths",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nCircularPolygon\nA polygon with circular arc sides.\n\n\nClosedPath\nA closed path that forms a Jordan curve.\n\n\nJuliaPath\nBase class for wrapping Julia path objects from ComplexRegions.jl.\n\n\nPath\nA path composed of connected curves.\n\n\nPolygon\nA polygon with straight sides.\n\n\nRectangle\nA rectangular polygon.\n\n\n\n\n\npaths.CircularPolygon(arg)\nA polygon with circular arc sides.\nThis class represents a polygon where each side can be either a straight line segment or a circular arc.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narg\nlist of curves or juliacall.AnyValue\nList of curves (segments and arcs) that form the polygon sides, or Julia CircularPolygon object to wrap\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\npath\nClosedPath\nThe underlying closed path\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Arc, Segment\n&gt;&gt;&gt; arc1 = Arc(1, 2 + 1j, 1j)\n&gt;&gt;&gt; seg1 = Segment(1j, -1)\n&gt;&gt;&gt; arc2 = Arc(-1, -0.5j, -1j)\n&gt;&gt;&gt; seg2 = Segment(-1j, 1)\n&gt;&gt;&gt; cpoly = CircularPolygon([arc1, seg1, arc2, seg2])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nside\nGet the k-th side of the polygon.\n\n\nsides\nGet all sides of the polygon.\n\n\n\n\n\npaths.CircularPolygon.side(k)\nGet the k-th side of the polygon.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the side\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nThe k-th side of the polygon\n\n\n\n\n\n\n\npaths.CircularPolygon.sides()\nGet all sides of the polygon.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist of JuliaCurve\nList of curves that form the polygon sides\n\n\n\n\n\n\n\n\n\npaths.ClosedPath(curves)\nA closed path that forms a Jordan curve.\nThis class represents a closed sequence of curves that form a continuous closed path, enabling computation of winding numbers and containment tests.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurves\nlist of JuliaCurve, Path, or juliacall.AnyValue\nList of curves that form the closed path, or Julia ClosedPath object to wrap\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Segment\n&gt;&gt;&gt; seg1 = Segment(0, 1)\n&gt;&gt;&gt; seg2 = Segment(1, 1+1j)\n&gt;&gt;&gt; seg3 = Segment(1+1j, 1j)\n&gt;&gt;&gt; seg4 = Segment(1j, 0)\n&gt;&gt;&gt; closed_path = ClosedPath([seg1, seg2, seg3, seg4])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisinside\nCheck if point z is inside the closed path.\n\n\nwinding\nCompute the winding number around point z.\n\n\n\n\n\npaths.ClosedPath.isinside(z)\nCheck if point z is inside the closed path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is inside the path, False otherwise\n\n\n\n\n\n\n\npaths.ClosedPath.winding(z)\nCompute the winding number around point z.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint around which to compute winding number\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nWinding number (positive for counterclockwise orientation)\n\n\n\n\n\n\n\n\n\npaths.JuliaPath(julia_obj)\nBase class for wrapping Julia path objects from ComplexRegions.jl.\nThis class provides a Python interface to Julia path objects, which are sequences of connected curves forming a continuous path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njulia_obj\njuliacall.AnyValue\nA Julia path object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\njulia\njuliacall.AnyValue\nThe underlying Julia path object\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nangles\nGet the turning angles at all vertices.\n\n\narclength\nCompute the total arc length of the path.\n\n\narg\nFind the parameter value corresponding to point z on the path.\n\n\nclosest\nFind the closest point on the path to z.\n\n\nconj\nReturn the complex conjugate of the path.\n\n\ncurve\nGet the k-th curve in the path.\n\n\ncurves\nGet all curves that make up the path.\n\n\ndist\nCompute the distance from point z to the path.\n\n\nget\nGet a field from the underlying Julia object.\n\n\nintersect\nFind intersection points with another path.\n\n\ninv\nCompute the inversion of the path with respect to the unit circle.\n\n\nisapprox\nCheck if this path is approximately equal to another.\n\n\nisfinite\nCheck if the path has finite length.\n\n\nispositive\nCheck if the path has positive orientation.\n\n\nisreal\nCheck if the path lies on the real axis.\n\n\nlength\nGet the number of curves in the path.\n\n\nnormal\nCompute the normal vector at parameter t.\n\n\npoint\nEvaluate the path at parameter value t.\n\n\nreflect\nReflect point z across the path.\n\n\nreverse\nReturn the path with reversed orientation.\n\n\ntangent\nCompute the tangent vector at parameter t.\n\n\nunittangent\nCompute the unit tangent vector at parameter t.\n\n\nvertex\nGet the k-th vertex of the path.\n\n\nvertices\nGet all vertices of the path.\n\n\n\n\n\npaths.JuliaPath.angles()\nGet the turning angles at all vertices.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray\nArray of turning angles at vertices\n\n\n\n\n\n\n\npaths.JuliaPath.arclength()\nCompute the total arc length of the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTotal arc length of all curves in the path\n\n\n\n\n\n\n\npaths.JuliaPath.arg(z)\nFind the parameter value corresponding to point z on the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to locate on the path\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat or None\nParameter value if z is on the path, None otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.closest(z)\nFind the closest point on the path to z.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nClosest point on the path to z\n\n\n\n\n\n\n\npaths.JuliaPath.conj()\nReturn the complex conjugate of the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath\nComplex conjugate of this path\n\n\n\n\n\n\n\npaths.JuliaPath.curve(k)\nGet the k-th curve in the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the curve (0-based)\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nThe k-th curve in the path\n\n\n\n\n\n\n\npaths.JuliaPath.curves()\nGet all curves that make up the path.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist of JuliaCurve\nList of curve objects that form the path\n\n\n\n\n\n\n\npaths.JuliaPath.dist(z)\nCompute the distance from point z to the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDistance from z to the closest point on the path\n\n\n\n\n\n\n\npaths.JuliaPath.get(field)\nGet a field from the underlying Julia object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfield\nstr\nName of the field to retrieve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe value of the requested field\n\n\n\n\n\n\n\npaths.JuliaPath.intersect(other)\nFind intersection points with another path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaPath\nAnother path to intersect with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray or other\nArray of intersection points or other result\n\n\n\n\n\n\n\npaths.JuliaPath.inv()\nCompute the inversion of the path with respect to the unit circle.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath\nInverted path\n\n\n\n\n\n\n\npaths.JuliaPath.isapprox(other)\nCheck if this path is approximately equal to another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaPath\nAnother path to compare with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if paths are approximately equal, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.isfinite()\nCheck if the path has finite length.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the path is finite, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.ispositive()\nCheck if the path has positive orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if positively oriented, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.isreal()\nCheck if the path lies on the real axis.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the path is real, False otherwise\n\n\n\n\n\n\n\npaths.JuliaPath.length()\nGet the number of curves in the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nNumber of curves in the path\n\n\n\n\n\n\n\npaths.JuliaPath.normal(t=0.0)\nCompute the normal vector at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nNormal vector at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.point(t)\nEvaluate the path at parameter value t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, typically in [0, 1]\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nPoint on the path at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.reflect(z)\nReflect point z across the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to reflect\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nReflected point\n\n\n\n\n\n\n\npaths.JuliaPath.reverse()\nReturn the path with reversed orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath\nPath with reversed orientation\n\n\n\n\n\n\n\npaths.JuliaPath.tangent(t=0.0)\nCompute the tangent vector at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nTangent vector at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.unittangent(t=0.0)\nCompute the unit tangent vector at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nUnit tangent vector at parameter t\n\n\n\n\n\n\n\npaths.JuliaPath.vertex(k)\nGet the k-th vertex of the path.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the vertex\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nCoordinates of the k-th vertex\n\n\n\n\n\n\n\npaths.JuliaPath.vertices()\nGet all vertices of the path.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray\nArray of vertex coordinates\n\n\n\n\n\n\n\n\n\npaths.Path(curves)\nA path composed of connected curves.\nThis class represents a sequence of curves that form a continuous path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurves\nlist of JuliaCurve or juliacall.AnyValue\nList of curves that form the path, or Julia Path object to wrap\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Segment\n&gt;&gt;&gt; seg1 = Segment(0, 1)\n&gt;&gt;&gt; seg2 = Segment(1, 1+1j)\n&gt;&gt;&gt; path = Path([seg1, seg2])\n\n\n\n\npaths.Polygon(arg)\nA polygon with straight sides.\nThis class represents a polygon where all sides are straight line segments.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\narg\nlist of complex or juliacall.AnyValue\nList of vertex coordinates or Julia Polygon object to wrap\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\npath\nClosedPath\nThe underlying closed path\n\n\n\n\n\n\n&gt;&gt;&gt; # Unit square\n&gt;&gt;&gt; poly = Polygon([0, 1, 1+1j, 1j])\n&gt;&gt;&gt; # More complex polygon\n&gt;&gt;&gt; poly2 = Polygon([4, 4 + 3j, 3j, -2j, 6 - 2j, 6])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nside\nGet the k-th side of the polygon.\n\n\nsides\nGet all sides of the polygon.\n\n\n\n\n\npaths.Polygon.side(k)\nGet the k-th side of the polygon.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nIndex of the side\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nThe k-th side of the polygon\n\n\n\n\n\n\n\npaths.Polygon.sides()\nGet all sides of the polygon.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist of JuliaCurve\nList of line segments that form the polygon sides\n\n\n\n\n\n\n\n\n\npaths.Rectangle(a, b=None)\nA rectangular polygon.\nThis class represents a rectangle, which is a special case of a polygon with four sides at right angles.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex, list, or juliacall.AnyValue\nCenter point, list of vertices, or Julia Rectangle object to wrap\nrequired\n\n\nb\narray - like or complex\nRadii array (if a is center) or opposite corner (if a is corner)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncenter\ncomplex\nCenter of the rectangle\n\n\nradii\narray - like\nHalf-widths in x and y directions\n\n\nrotation\nfloat\nRotation angle of the rectangle\n\n\npolygon\nPolygon\nThe underlying polygon representation\n\n\n\n\n\n\n&gt;&gt;&gt; # Rectangle from center and radii\n&gt;&gt;&gt; rect1 = Rectangle(0+0j, np.array([1.0, 0.5]))\n&gt;&gt;&gt; # Rectangle from opposite corners\n&gt;&gt;&gt; rect2 = Rectangle(-1-1j, 1+1j)"
  },
  {
    "objectID": "reference/paths.html#functions",
    "href": "reference/paths.html#functions",
    "title": "paths",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_julia\nExtract the Julia object from a Python wrapper.\n\n\nn_gon\nConstruct a regular n-gon as a Polygon object.\n\n\nquad\nConstruct a quadrilateral region from a Rectangle.\n\n\nwrap_jl_path\nWrap a Julia path object in the appropriate Python class.\n\n\n\n\n\npaths.get_julia(p)\nExtract the Julia object from a Python wrapper.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\nJuliaCurve, JuliaPath, or other\nPython wrapper object or raw Julia object\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njuliacall.AnyValue or other\nThe underlying Julia object, or the input if not a wrapper\n\n\n\n\n\n\n\npaths.n_gon(n)\nConstruct a regular n-gon as a Polygon object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of sides\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nPolygon\nRegular n-sided polygon centered at origin with unit circumradius\n\n\n\n\n\n\n&gt;&gt;&gt; # Regular hexagon\n&gt;&gt;&gt; hex_poly = n_gon(6)\n&gt;&gt;&gt; # Regular triangle\n&gt;&gt;&gt; triangle = n_gon(3)\n\n\n\n\npaths.quad(rect)\nConstruct a quadrilateral region from a Rectangle.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrect\nRectangle\nRectangle to convert to a region\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nInterior region of the rectangle\n\n\n\n\n\n\n&gt;&gt;&gt; rect = Rectangle(0+0j, np.array([1.0, 0.5]))\n&gt;&gt;&gt; region = quad(rect)\n\n\n\n\npaths.wrap_jl_path(jul)\nWrap a Julia path object in the appropriate Python class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njul\njuliacall.AnyValue\nA Julia path object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nPath\nThe appropriate Python path wrapper\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a Julia object or not a recognized path type"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Submodules containing core functionality\n\n\n\ncurves\nCurve classes for the cxregions package.\n\n\npaths\nPath classes for the cxregions package.\n\n\nregions\nRegion classes for the cxregions package.\n\n\nmobius\nMöbius transformation class for the cxregions package."
  },
  {
    "objectID": "reference/index.html#modules",
    "href": "reference/index.html#modules",
    "title": "Function reference",
    "section": "",
    "text": "Submodules containing core functionality\n\n\n\ncurves\nCurve classes for the cxregions package.\n\n\npaths\nPath classes for the cxregions package.\n\n\nregions\nRegion classes for the cxregions package.\n\n\nmobius\nMöbius transformation class for the cxregions package."
  },
  {
    "objectID": "polygons.html",
    "href": "polygons.html",
    "title": "Polygons",
    "section": "",
    "text": "There are two specialized subtypes of the ClosedPath type: CircularPolygon and its subtype Polygon.",
    "crumbs": [
      "Home",
      "Polygons"
    ]
  },
  {
    "objectID": "polygons.html#circularpolygon",
    "href": "polygons.html#circularpolygon",
    "title": "Polygons",
    "section": "CircularPolygon",
    "text": "CircularPolygon\nA CircularPolygon is a closed path whose curve components all have type Arc, Ray, and Segment. In contrast to the usual notion of a polygon, the path may be unbounded. Construct a value by calling CircularPolygon(c) with a vector or Path of curves of appropriate types; continuity and closure of the path are checked as necessary.\nIn addition to the usual methods for a ClosedPath, the following are implemented:\n\n\n\nMethod\nDescription\n\n\n\n\nside\nAlias for curve.\n\n\nP.winding(z)\nWinding number of P relative to z.\n\n\nP.truncate()\nReplace infinite sides with finite ones.",
    "crumbs": [
      "Home",
      "Polygons"
    ]
  },
  {
    "objectID": "polygons.html#polygon",
    "href": "polygons.html#polygon",
    "title": "Polygons",
    "section": "Polygon",
    "text": "Polygon\nA Polygon is a closed path whose curve components all have type Ray and Segment. In contrast to the usual notion of a polygon, the path may be unbounded. Construct a value by calling Polygon(c) with a vector or Path of curves of appropriate types; continuity and closure of the path are checked as necessary.\nAn alternative construction is to provide a vector of vertices. In place of an infinite vertex, you can supply a tuple of the angles of the two rays that meet there. See the examples section below.\nIn addition to the methods for CircularPolygon, the Polygon type offers\n\n\n\nMethod\nDescription\n\n\n\n\nP.angles()\nInterior angles of the polygon.\n\n\n\nAngles at a finite vertex are in the interval \\((0, 2\\pi]\\), while angles at an infinite vertex are in \\([-2\\pi, 0]\\), representing the angle at the pole of the Riemann sphere.\nTwo additional special polygon constructors are defined:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nrectangle(xlim, ylim) or rectangle(z1, z2)\nConstruct an axes-aligned rectangle.\n\n\nn_gon(n)\nConstruct a regular n-gon with unit vertices.",
    "crumbs": [
      "Home",
      "Polygons"
    ]
  },
  {
    "objectID": "polygons.html#examples",
    "href": "polygons.html#examples",
    "title": "Polygons",
    "section": "Examples",
    "text": "Examples\n\nfrom cxregions import *\nimport numpy as np\n\nDetected IPython. Loading juliacall extension. See https://juliapy.github.io/PythonCall.jl/stable/compat/#IPython\n\n\nA big plus:\n\nbox = [1-1j, 3-1j, 3+1j]\nplus = Polygon([*box, *[1j*z for z in box], *[-z for z in box], *[-1j*z for z in box]])\nprint(f\"angles of plus polygon: {plus.angles() / np.pi} * π\")\n\nangles of plus polygon: [1.5 0.5 0.5 1.5 0.5 0.5 1.5 0.5 0.5 1.5 0.5 0.5] * π\n\n\nA Koch snowflake:\n\nv = n_gon(3).vertices()\npattern = [1] + [(z - v[0]) / (v[0] - v[2])/3 + 2/3 for z in v]\n\ndef koch(a, b):\n    return [b + (a - b) * p for p in pattern]\n\nfor m in range(3):\n    n = len(v)\n    print(f\"Iteration {m+1}: n = {n}\")\n    v = [point for k in range(n) for point in koch(v[k], v[(k+1) % n])]\n\nkoch_polygon = Polygon(v)\nprint(f\"Final Koch snowflake has {len(v)} vertices\")\n\nIteration 1: n = 3\nIteration 2: n = 12\nIteration 3: n = 48\nFinal Koch snowflake has 192 vertices\n\n\nInfinite channel with a step, using tuples to specify the angles of rays going to infinity:\n\np = Polygon([0, -1j, (0, 0), 1j, (np.pi, np.pi)])\nprint(f\"angles of channel polygon: {p.angles() / np.pi} * π\")\n\nangles of channel polygon: [1.5 0.5 0.  1.  0. ] * π",
    "crumbs": [
      "Home",
      "Polygons"
    ]
  },
  {
    "objectID": "mobius.html",
    "href": "mobius.html",
    "title": "Mobius",
    "section": "",
    "text": "A Möbius transformation (also called bilinear or fractional-linear transformation) is the ratio of two linear polynomials:\n\\[\nf(z)=\\frac{az+b}{cz+d}.\n\\]\nAmong other notable properties, they map circles and lines to other circles and lines.\nThe package defines a Mobius type that can be constructed in a variety of ways:\n\n\n\nConstruction\nDescription\n\n\n\n\nMobius(a, b, c, d)\nSpecify the coefficients as in the formula above.\n\n\nMobius(A)\nSpecify the coefficients as an array \\(A=[a\\;b;\\;\\,c\\;d]\\).\n\n\nMobius(z, w)\nConstruct the unique transformation that maps the three points z[1], z[2], z[3] to w[1], w[2], w[3], respectively. Either vector of points may include Inf.\n\n\nMobius(C1, C2)\nConstruct a transformation that maps the Line or Circle C1 to the Line or Circle C2.\n\n\n\n\n\n\n\n\n\nSuppose f is a value of type Mobius. Then f(z) evaluates the transformation at the number z. In addition, f(C), where C is a Circle or Line, returns the Circle or Line that is the image of C under f. Similarly, f(R), where R is a disk or half-plane, returns the appropriate type of image region. For example,\n\nfrom cxregions import Mobius, Line, Circle, unitcircle\nf = Mobius(Line(-1, 1), Circle(0, 1))\nf(Line(-1, 1)).isapprox(unitcircle)\n\nDetected IPython. Loading juliacall extension. See https://juliapy.github.io/PythonCall.jl/stable/compat/#IPython\n\n\nTrue\n\n\nTwo other methods are defined:\n\ninv(f) Construct the inverse transformation.\nf.compose(g) Construct the composed map, \\(z \\mapsto f(g(z))\\).",
    "crumbs": [
      "Home",
      "Mobius"
    ]
  },
  {
    "objectID": "mobius.html#methods",
    "href": "mobius.html#methods",
    "title": "Mobius",
    "section": "",
    "text": "Suppose f is a value of type Mobius. Then f(z) evaluates the transformation at the number z. In addition, f(C), where C is a Circle or Line, returns the Circle or Line that is the image of C under f. Similarly, f(R), where R is a disk or half-plane, returns the appropriate type of image region. For example,\n\nfrom cxregions import Mobius, Line, Circle, unitcircle\nf = Mobius(Line(-1, 1), Circle(0, 1))\nf(Line(-1, 1)).isapprox(unitcircle)\n\nDetected IPython. Loading juliacall extension. See https://juliapy.github.io/PythonCall.jl/stable/compat/#IPython\n\n\nTrue\n\n\nTwo other methods are defined:\n\ninv(f) Construct the inverse transformation.\nf.compose(g) Construct the composed map, \\(z \\mapsto f(g(z))\\).",
    "crumbs": [
      "Home",
      "Mobius"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cxregions",
    "section": "",
    "text": "This package provides classes and methods that are useful for working with curves and regions in the (extended) complex plane. It presents a Pythonic interface to the functionality provided by the Julia package ComplexRegions.jl, which is the computational engine. Julia and the necessary dependencies are installed automatically when you first use cxregions.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#core-classes",
    "href": "index.html#core-classes",
    "title": "cxregions",
    "section": "Core classes",
    "text": "Core classes\nThese are three core classes in the package. Each is in a submodule of the same name, but are also imported into the top-level namespace for convenience. In general, names follow Julian conventions rather than Python conventions.\n\ncurves\nA curve is a smooth curve in the extended complex plane. Implicitly, curves are expected to be non-self-intersecting, but that condition is not enforced. The generic Curve type requires you to specify explicit parameterizations for the point and tangent that are not checked for smoothness. Particular predefined subtypes are Circle, Arc, Line, Ray, and Segment.\n\n\npaths\nA path is a piecewise-continuous complex-valued path. In practice, a Path can be specified as a vector of curves. The path is checked for continuity at creation time. The most important provided specific path subtypes are Polygon and CircularPolygon.\nBoth curves and paths have closed subtypes. These are additionally checked at creation to ensure that the initial and final points are the same.\nOne atypical aspect of curves and paths, even “closed” ones, is that they lie in the extended or compactified complex plane and thus may be unbounded. For instance, a line in the plane may be interpreted as a circle on the Riemann sphere, and is thus a closed curve passing through infinity.\n\n\nregions\nA region is an open region in the extended plane bounded by closed curves or paths. These include the simply connected Interior1CRegion and Exterior1CRegion types, which are bounded by a single closed curve or path, as well as more complicated multiply connected regions bounded by several such objects.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#tolerance",
    "href": "index.html#tolerance",
    "title": "cxregions",
    "section": "Tolerance",
    "text": "Tolerance\nBoundaries and endpoints are not well-posed ideas in floating-point, since an arbitrarily small perturbation to a value can move a point on or off of them. Thus, many concepts in the package such as intersection or continuity are checked only up to a small tolerance. This value defaults to a modest multiple of machine precision and can be overridden on a per-call basis.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "curves.html",
    "href": "curves.html",
    "title": "Curves",
    "section": "",
    "text": "A curve is a smooth, non-self-intersecting curve in the extended complex plane. The curve parameter is a real number in the range \\([0,1]\\) that is used to traverse the curve.",
    "crumbs": [
      "Home",
      "Curves"
    ]
  },
  {
    "objectID": "curves.html#curve-base-class",
    "href": "curves.html#curve-base-class",
    "title": "Curves",
    "section": "Curve base class",
    "text": "Curve base class\nEvery Curve subtype is expected to implement the following methods. (Here C represents a value of type Curve and z is a number.)\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nC.point(t), or C(t)\nComplex point on C at parameter value t in [0,1].\n\n\nC.tangent(t)\nComplex tangent to C at t.\n\n\nC.unittangent(t)\nNormalized tangent to C at t.\n\n\nC.normal(t)\nUnit (leftward) normal to C at t.\n\n\nC.arclength()\nArc length of C.\n\n\nC.reverse()\nReverse the direction of traversal.\n\n\nC.isfinite()\nTrue if the curve does not pass through infinity.\n\n\nC.conj()\nComplex conjugate of the curve.\n\n\nC + z, z + C\nTranslation of the curve by z.\n\n\nC - z\nTranslation of the curve by z.\n\n\n-C\nNegate the curve.\n\n\nC * z\nMultiply the curve C by complex number z; i.e., scale and rotate it about the origin.\n\n\ninv(C)\nInvert the curve pointwise through the origin.\n\n\n\nA Curve object represents an implementation given by a manually specified parameterization of the curve and its tangent. Given the (bounded) complex-valued functions \\(f\\) and \\(df\\) defined on \\([0,1]\\), then Curve(f, df) represents the curve \\(z=f(t)\\). If \\(f\\) is defined on \\([a, b]\\) instead, then Curve(f, df, a, b) is appropriate, but all future work with the curve object uses the standard interval \\([0,1]\\) for the parameter. All Curve values are expected to be finite; i.e., C.isfinite() will always be true.",
    "crumbs": [
      "Home",
      "Curves"
    ]
  },
  {
    "objectID": "curves.html#closedcurve",
    "href": "curves.html#closedcurve",
    "title": "Curves",
    "section": "ClosedCurve",
    "text": "ClosedCurve\nThe ClosedCurve subtype is used to signify that the starting and ending points of the curve are (approximately) identical. In addition to the methods of Curve, it provides the following:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nC.winding(z)\nWinding number of C about z.\n\n\nC.hasinside(z::Number, C)\nDetect whether z lies inside the curve.",
    "crumbs": [
      "Home",
      "Curves"
    ]
  },
  {
    "objectID": "curves.html#predefined-curve-subtypes",
    "href": "curves.html#predefined-curve-subtypes",
    "title": "Curves",
    "section": "Predefined Curve subtypes",
    "text": "Predefined Curve subtypes\nIn addition to the minimal methods for all Curve objects, each of the subtypes below provides the following methods. (C is a value of one of these types, and z is a number.)\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nC.arg(z)\nCurve parameter value of a given point on the curve.\n\n\nC1.isapprox(C2)\nDetermine whether two values represent the same curve.\n\n\nC.isleft(z), C.isright(z)\nDetermine whether a point lies “to the left” or “to the right” of a line, ray, or segment in its given orientation.\n\n\nC.dist(z)\nDistance from a point to the curve.\n\n\nC.closest(z)\nPoint on the curve nearest to a given number.\n\n\n\n\nLine\nLike other curves, a line is parameterized over \\([0,1]\\), with L(0) and L(1) both being infinity.\n\nLine(a, b) creates the line through the values \\(a\\) and \\(b\\).\nLine(p, direction=s) creates a line through the point p in the direction of the complex number s.\nLine(p, angle=theta) creates a line through the point p at the angle theta.\n\nUse L.reflect(z) to find the reflection of a point z across line L.\n\n\nRay\n\nRay(z, theta) constructs a ray starting at z and extending to infinity at the angle theta.\nRay(z, theta, true) constructs a ray starting at infinity and extending to z at the angle theta.\n\n\n\nSegment\n\nSegment(a, b) constructs the line segment from a to b.\n\n\n\nCircle\n\nCircle(z, r) constructs a circle centered at z with radius r, oriented counterclockwise.\nCircle(z, r, false) constructs the circle with clockwise orientation.\nCircle(a, b, c) constructs the circle through the points a, b, and c. The ordering of the points determines the orientation of the circle. If the points are collinear, a Line is returned instead.\n\nUse C.reflect(z) to reflect a point z through the circle C.\n\n\nArc\n\nArc(a, b, c) constructs the circular arc through the given three points. If the points are collinear, a Segment is returned.\nArc(C, start, delta) constructs an arc from a Circle C, starting at the given start value and extending an amount delta. The values are expressed as fractions of a full rotation starting from the real axis.",
    "crumbs": [
      "Home",
      "Curves"
    ]
  },
  {
    "objectID": "curves.html#examples",
    "href": "curves.html#examples",
    "title": "Curves",
    "section": "Examples",
    "text": "Examples\n\nfrom cxregions import *\n\nDetected IPython. Loading juliacall extension. See https://juliapy.github.io/PythonCall.jl/stable/compat/#IPython\n\n\n\nL = Line(1/2, 1/2 + 1j)    # line through 0.5 and 0.5+1i\nprint(L)\n\nLine through (0.5+0j) at angle 0.5 * pi\n\n\n\nc = L.inv()   # a circle\nprint(c)\n\nCircle centered at (1-2.7755575615628914e-17j) with radius 1.0\n\n\n\nprint(f\"winding of c about z = 1.5:   {c.winding(1.5)}\")\nprint(f\"winding of c about z = -1:   {c.winding(-1)}\")\nprint(f\"tangent of c at 0.75:   {c.tangent(0.75)}\")\nprint(f\"reflection of -1 across c:   {c.reflect(-1)}\")\nprint(f\"2*c - 2:   {2*c - 2}\")\n\nwinding of c about z = 1.5:   -1\nwinding of c about z = -1:   0\ntangent of c at 0.75:   (6.283185307179586+0j)\nreflection of -1 across c:   (0.5-2.0816681711721685e-17j)\n2*c - 2:   Circle centered at -5.551115123125783e-17j with radius 2.0",
    "crumbs": [
      "Home",
      "Curves"
    ]
  },
  {
    "objectID": "intersections.html",
    "href": "intersections.html",
    "title": "Intersections",
    "section": "",
    "text": "Methods are provided to find intersections between all the specific subtypes of curve (i.e., not those with an externally provided parameterization). In the generic cases where the intersections consist of zero or more points, a vector of results is returned. In special circumstances of partially or wholly overlapping curves, a Curve subtype is returned.\nThere are also methods for finding the intersections between curves and paths, and between two paths. These return set unions over the curves of the path(s), returning a vector with complex element type or, if some overlaps occurred, mixed types.",
    "crumbs": [
      "Home",
      "Intersections"
    ]
  },
  {
    "objectID": "intersections.html#examples",
    "href": "intersections.html#examples",
    "title": "Intersections",
    "section": "Examples",
    "text": "Examples\n\nfrom cxregions import *\n\nDetected IPython. Loading juliacall extension. See https://juliapy.github.io/PythonCall.jl/stable/compat/#IPython\n\n\nCircles and Arcs intersect at zero, one, or two points, or as an Arc.\n\nc = Circle(0, 1)\na = Arc(1+1j, 0, 1-1j)\nb = Arc(1j, 1, -1j)\n\nprint(f\"intersection of c and a: {c.intersect(a)}\")\nb_and_c = b.intersect(c)\nprint(f\"type of b ∩ c:   {type(b_and_c)}\")\nprint(f\"is b ∩ c approximately b?   {b.isapprox(b_and_c)}\")\n\nintersection of c and a: [0.5-0.8660254j 0.5+0.8660254j]\ntype of b ∩ c:   &lt;class 'cxregions.curves.Arc'&gt;\nis b ∩ c approximately b?   True\n\n\nSegments and Lines intersect at zero or one point, or as a Line or Segment.\n\nl = Line(1j, 1+1j)\ns = Segment(-2, 2+2j)\nprint(f\"intersection of l and s:        {l.intersect(s)}\")\nprint(f\"intersection of l and s + 2j:   {l.intersect(s + 2j)}\")\nprint(f\"intersection of s and Segment(-4-1j, 1j):   {s.intersect(Segment(-4-1j, 1j))}\")\n\nintersection of l and s:        [0.+1.j]\nintersection of l and s + 2j:   []\nintersection of s and Segment(-4-1j, 1j):   Segment from (-2+0j) to 1j\n\n\n\nL = Line(1/2, 1/2+1j)    # line through 0.5 and 0.5+1i\nc = L.inv()    # a circle\nprint(f\"intersection of L and c:   {L.intersect(c)}\")\n\nintersection of L and c:   [0.5+0.8660254j 0.5-0.8660254j]",
    "crumbs": [
      "Home",
      "Intersections"
    ]
  },
  {
    "objectID": "paths.html",
    "href": "paths.html",
    "title": "Paths",
    "section": "",
    "text": "A path is a sequence of Curve values that compose a continuous, complex-valued path. A path with \\(n\\) components is parameterized over the interval \\([0, n]\\), with the first component covering \\([0, 1]\\), the second covering \\([1, 2]\\), and so on. The path is checked for continuity at the vertices at construction time.",
    "crumbs": [
      "Home",
      "Paths"
    ]
  },
  {
    "objectID": "paths.html#path-base-class",
    "href": "paths.html#path-base-class",
    "title": "Paths",
    "section": "Path base class",
    "text": "Path base class\nA path is created by calling Path(c), where c is a vector of curves subtyped from Curve. The constructor tests the endpoints of the given curves for continuity up to a selectable tolerance.\nEvery Path subtype provides the following method:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nP.curve(k)\nkth curve of P.\n\n\nP.curves()\nReturn a vector of the curves constituting P.\n\n\nP.vertices()\nVertices of P (the endpoints of the constituent curves)\n\n\nP.vertex(k)\nkth vertex of P.\n\n\nlen(P)\nNumber of curves in the path.\n\n\nP.isfinite()\nTrue if the path is bounded.\n\n\nP.point(t)\nPoint on the path.\n\n\nP.point(t_array)\nVectorization of point.\n\n\nP.tangent(t)\nComplex-valued tangent at a point.\n\n\nP.unittangent(t)\nNormalized tangent at a point.\n\n\nP.normal(t)\nLeftward-pointing unit normal at a point.\n\n\nP.conj()\nComplex conjugate of the path.\n\n\nP.reverse()\nReverse the orientation of the path.\n\n\nP + z, P - z, P * z, P / z\nTranslate, rotate and scale a path.\n\n\nP1.isapprox(P2)\nDetermine whether two values represent the same path.\n\n\nP.arclength()\nArc length of the path.\n\n\nP.dist(z)\nDistance from a point to the path.\n\n\nP.closest(z)\nPoint on the path nearest to a given number.",
    "crumbs": [
      "Home",
      "Paths"
    ]
  },
  {
    "objectID": "paths.html#closedpath",
    "href": "paths.html#closedpath",
    "title": "Paths",
    "section": "ClosedPath",
    "text": "ClosedPath\nThe chief difference from the Path type is that the constructor also checks whether the initial and final points coincide (up to tolerance). The ClosedPath subtype modifies a few of the implementations above:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nP.vertices()\nOnly the unique vertices; i.e., does not duplicate the initial/final vertex.\n\n\nP.curve(k)\nkth curve of the path in a circular/modulo sense.\n\n\nP.vertex(k)\nkth vertex of the path in a circular/modulo sense.\n\n\nP.point(), P.tangent(), P.unittangent(), P.normal()\nUse a circular/modulo interpretation of the parameter.\n\n\nP.winding(z)\nWinding number of P about z.\n\n\nP.isinside(z)\nDetect whether z lies inside the path.\n\n\nP.isoutside(z)\nDetect whether z lies outside the path.",
    "crumbs": [
      "Home",
      "Paths"
    ]
  },
  {
    "objectID": "paths.html#examples",
    "href": "paths.html#examples",
    "title": "Paths",
    "section": "Examples",
    "text": "Examples\n\nfrom cxregions import *\n\nDetected IPython. Loading juliacall extension. See https://juliapy.github.io/PythonCall.jl/stable/compat/#IPython\n\n\nHere is a path defined by arcs and segments.\n\na = Arc(-1, 1, -1j)\nright = Path([4 + 1j + a, 4 - 1j - 1j * a])\ns = Segment(-3 + 1j, 3 + 1j)\np = ClosedPath([s, *right, -s, *(-right)])\nprint(p)\n\nClosed path with 6 curves\n\n\n\nprint(f\"Arc length: {p.arclength()}\")\nprint(f\"Vertices: {p.vertices()}\")\n\nArc length: 30.84955592153876\nVertices: [-3.+1.j  3.+1.j  4.+0.j  3.-1.j -3.-1.j -4.+0.j]",
    "crumbs": [
      "Home",
      "Paths"
    ]
  },
  {
    "objectID": "reference/curves.html",
    "href": "reference/curves.html",
    "title": "curves",
    "section": "",
    "text": "curves\nCurve classes for the cxregions package.\nThis module contains all curve-related classes including the base JuliaCurve class and specific curve types like Line, Circle, Segment, Ray, and Arc.\n\n\n\n\n\nName\nDescription\n\n\n\n\nunitcircle\nUnit circle centered at the origin.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nArc\nA circular arc in the complex plane.\n\n\nCircle\nA circle in the complex plane.\n\n\nClosedCurve\nA closed parametric curve in the complex plane.\n\n\nCurve\nA general parametric curve in the complex plane.\n\n\nJuliaCurve\nBase class for wrapping Julia curve objects from ComplexRegions.jl.\n\n\nLine\nAn infinite straight line in the complex plane.\n\n\nRay\nA semi-infinite ray in the complex plane.\n\n\nSegment\nA line segment in the complex plane.\n\n\n\n\n\ncurves.Arc(a, b=None, c=None)\nA circular arc in the complex plane.\nAn arc is a portion of a circle between two points.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex, Circle, or juliacall.AnyValue\nStart point, circle, or Julia Arc object to wrap\nrequired\n\n\nb\ncomplex\nEnd point (if a is start point)\nNone\n\n\nc\ncomplex\nCenter point (if constructing from start, end, center)\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncircle\nCircle or Segment\nThe underlying circle (or degenerate segment)\n\n\nstart\nfloat\nStarting parameter on the circle\n\n\ndelta\nfloat\nParameter range of the arc\n\n\n\n\n\n\n&gt;&gt;&gt; # Quarter circle arc from 1 to i around origin\n&gt;&gt;&gt; arc = Arc(1, 1j, 0)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the arc with respect to the origin.\n\n\n\n\n\ncurves.Arc.inv()\nCompute the inversion of the arc with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArc, Ray, or Segment\nThe type depends on the geometry after inversion\n\n\n\n\n\n\n\n\n\ncurves.Circle(a, b=None, c=None, ccw=True)\nA circle in the complex plane.\nCircles can be constructed in several ways: - From center and radius - From three points on the circle - From a Julia Circle object\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex or juliacall.AnyValue\nCenter point, first point on circle, or Julia Circle object\nrequired\n\n\nb\nfloat or complex\nRadius (if a is center) or second point on circle\nNone\n\n\nc\ncomplex\nThird point on circle (if constructing from three points)\nNone\n\n\nccw\nbool\nWhether the circle has counterclockwise orientation, default True\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncenter\ncomplex\nCenter of the circle\n\n\nradius\nfloat\nRadius of the circle\n\n\nccw\nbool\nWhether the circle has counterclockwise orientation\n\n\n\n\n\n\n&gt;&gt;&gt; # Unit circle at origin\n&gt;&gt;&gt; circle1 = Circle(0, 1)\n&gt;&gt;&gt; # Circle from center and radius with clockwise orientation\n&gt;&gt;&gt; circle2 = Circle(1+1j, 2, ccw=False)\n&gt;&gt;&gt; # Circle through three points\n&gt;&gt;&gt; circle3 = Circle(1, 1j, -1)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the circle with respect to the origin.\n\n\nisfinite\nCheck if the circle is finite.\n\n\nispositive\nCheck if the circle has positive (counterclockwise) orientation.\n\n\n\n\n\ncurves.Circle.inv()\nCompute the inversion of the circle with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCircle or Line\nCircle if the original circle doesn’t pass through the origin, Line if it does\n\n\n\n\n\n\n\ncurves.Circle.isfinite()\nCheck if the circle is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns True for circles\n\n\n\n\n\n\n\ncurves.Circle.ispositive()\nCheck if the circle has positive (counterclockwise) orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if counterclockwise, False if clockwise\n\n\n\n\n\n\n\n\n\ncurves.ClosedCurve(point, tangent=None, domain=(0.0, 1.0))\nA closed parametric curve in the complex plane.\nThis class represents a closed curve that forms a Jordan curve, enabling computation of winding numbers and interior/exterior tests.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npoint\ncallable or juliacall.AnyValue\nEither a function that maps parameter values to complex points, or a Julia closed curve object to wrap\nrequired\n\n\ntangent\ncallable\nFunction that maps parameter values to tangent vectors\nNone\n\n\ndomain\ntuple of float\nParameter domain as (start, end), default is (0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n&gt;&gt;&gt; # Create a closed curve (unit circle)\n&gt;&gt;&gt; point = lambda t: np.exp(2j * np.pi * t)\n&gt;&gt;&gt; tangent = lambda t: 2j * np.pi * np.exp(2j * np.pi * t)\n&gt;&gt;&gt; curve = ClosedCurve(point, tangent)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nhasinside\nCheck if point z is in the interior of the closed curve.\n\n\nwinding\nCompute the winding number of the curve around point z.\n\n\n\n\n\ncurves.ClosedCurve.hasinside(z)\nCheck if point z is in the interior of the closed curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is in the interior, False otherwise\n\n\n\n\n\n\n\ncurves.ClosedCurve.winding(z)\nCompute the winding number of the curve around point z.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint around which to compute winding number\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nWinding number (positive for counterclockwise orientation)\n\n\n\n\n\n\n\n\n\ncurves.Curve(point, tangent=None, domain=(0.0, 1.0))\nA general parametric curve in the complex plane.\nThis class represents a curve defined by a point function and optional tangent function over a parameter domain.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npoint\ncallable or juliacall.AnyValue\nEither a function that maps parameter values to complex points, or a Julia curve object to wrap\nrequired\n\n\ntangent\ncallable\nFunction that maps parameter values to tangent vectors\nNone\n\n\ndomain\ntuple of float\nParameter domain as (start, end), default is (0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n&gt;&gt;&gt; # Create a curve from a function\n&gt;&gt;&gt; curve = Curve(lambda t: t + 1j*t**2, lambda t: 1 + 2j*t)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the curve with respect to the origin.\n\n\n\n\n\ncurves.Curve.inv()\nCompute the inversion of the curve with respect to the origin.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCurve\nInverted curve\n\n\n\n\n\n\n\n\n\ncurves.JuliaCurve(julia_obj)\nBase class for wrapping Julia curve objects from ComplexRegions.jl.\nThis class provides a Python interface to Julia curve objects, handling the conversion between Python and Julia types and providing access to geometric operations on curves.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njulia_obj\njuliacall.AnyValue\nA Julia curve object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\njulia\njuliacall.AnyValue\nThe underlying Julia curve object\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\narclength\nCompute the arc length of the curve.\n\n\narg\nFind the parameter value corresponding to point z on the curve.\n\n\nclosest\nFind the closest point on the curve to z.\n\n\nconj\nReturn the complex conjugate of the curve.\n\n\ndist\nCompute the distance from point z to the curve.\n\n\nget\nGet a field from the underlying Julia object.\n\n\nintersect\nFind intersection points with another curve.\n\n\ninv\nCompute the inversion of the curve with respect to the origin.\n\n\nisapprox\nCheck if this curve is approximately equal to another.\n\n\nisfinite\nCheck if the curve has finite length.\n\n\nisleft\nCheck if point z is to the left of the curve.\n\n\nispositive\nCheck if the curve has positive orientation.\n\n\nisreal\nCheck if the curve lies on the real axis.\n\n\nisright\nCheck if point z is to the right of the curve.\n\n\nnormal\nCompute the normal at parameter t.\n\n\npoint\nEvaluate the curve at parameter value t.\n\n\nreflect\nReflect point z across the curve.\n\n\nreverse\nReturn the curve with reversed orientation.\n\n\ntangent\nCompute the tangent at parameter t.\n\n\nunittangent\nCompute the unit tangent at parameter t.\n\n\n\n\n\ncurves.JuliaCurve.arclength()\nCompute the arc length of the curve.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTotal arc length of the curve\n\n\n\n\n\n\n\ncurves.JuliaCurve.arg(z)\nFind the parameter value corresponding to point z on the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to locate on the curve\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat or None\nParameter value if z is on the curve, None otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.closest(z)\nFind the closest point on the curve to z.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nClosest point on the curve to z\n\n\n\n\n\n\n\ncurves.JuliaCurve.conj()\nReturn the complex conjugate of the curve.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nComplex conjugate of this curve\n\n\n\n\n\n\n\ncurves.JuliaCurve.dist(z)\nCompute the distance from point z to the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDistance from z to the closest point on the curve\n\n\n\n\n\n\n\ncurves.JuliaCurve.get(field)\nGet a field from the underlying Julia object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfield\nstr\nName of the field to retrieve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe value of the requested field\n\n\n\n\n\n\n\ncurves.JuliaCurve.intersect(other)\nFind intersection points with another curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaCurve\nAnother curve to intersect with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray or JuliaCurve\nArray of intersection points, or a curve if the intersection is a continuous curve segment\n\n\n\n\n\n\n\ncurves.JuliaCurve.inv()\nCompute the inversion of the curve with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njuliacall.AnyValue\nJulia object representing the inverted curve\n\n\n\n\n\n\nThis method returns a raw Julia object. Subclasses should override this method to return properly wrapped Python objects.\n\n\n\n\ncurves.JuliaCurve.isapprox(other)\nCheck if this curve is approximately equal to another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaCurve\nAnother curve to compare with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if curves are approximately equal, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isfinite()\nCheck if the curve has finite length.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the curve is finite, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isleft(z)\nCheck if point z is to the left of the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is to the left of the curve, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.ispositive()\nCheck if the curve has positive orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if positively oriented, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isreal()\nCheck if the curve lies on the real axis.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the curve is real, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isright(z)\nCheck if point z is to the right of the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is to the right of the curve, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.normal(t)\nCompute the normal at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nNormal at parameter t\n\n\n\n\n\n\n\ncurves.JuliaCurve.point(t)\nEvaluate the curve at parameter value t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, typically in [0, 1]\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nPoint on the curve at parameter t\n\n\n\n\n\n\n\ncurves.JuliaCurve.reflect(z)\nReflect point z across the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to reflect\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nReflected point\n\n\n\n\n\n\n\ncurves.JuliaCurve.reverse()\nReturn the curve with reversed orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nCurve with reversed orientation\n\n\n\n\n\n\n\ncurves.JuliaCurve.tangent(t=0.0)\nCompute the tangent at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nTangent at parameter t\n\n\n\n\n\n\n\ncurves.JuliaCurve.unittangent(t=0.0)\nCompute the unit tangent at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nUnit tangent at parameter t\n\n\n\n\n\n\n\n\n\ncurves.Line(a, b=None, direction=None)\nAn infinite straight line in the complex plane.\nA line can be constructed from two points, or from a point and a direction. Lines have infinite arc length and are always considered to have positive orientation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex or juliacall.AnyValue\nEither a point on the line, or a Julia Line object to wrap\nrequired\n\n\nb\ncomplex\nSecond point on the line (if constructing from two points)\nNone\n\n\ndirection\ncomplex\nDirection vector of the line (if constructing from point and direction)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbase\ncomplex\nA base point on the line\n\n\ndirection\ncomplex\nDirection vector of the line\n\n\n\n\n\n\n&gt;&gt;&gt; # Line through two points\n&gt;&gt;&gt; line1 = Line(0, 1+1j)\n&gt;&gt;&gt; # Line through origin with given direction\n&gt;&gt;&gt; line2 = Line(0, direction=1+1j)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nangle\nGet the angle of the line’s direction vector.\n\n\narclength\nReturn infinite arc length for lines.\n\n\ninv\nCompute the inversion of the line with respect to the origin.\n\n\nisfinite\nCheck if the line is finite.\n\n\nispositive\nCheck if the line has positive orientation.\n\n\nslope\nGet the slope of the line.\n\n\n\n\n\ncurves.Line.angle()\nGet the angle of the line’s direction vector.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nAngle in radians\n\n\n\n\n\n\n\ncurves.Line.arclength()\nReturn infinite arc length for lines.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nAlways returns numpy.inf\n\n\n\n\n\n\n\ncurves.Line.inv()\nCompute the inversion of the line with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCircle or Line\nCircle if the line doesn’t pass through the origin, Line otherwise\n\n\n\n\n\n\n\ncurves.Line.isfinite()\nCheck if the line is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns False for lines\n\n\n\n\n\n\n\ncurves.Line.ispositive()\nCheck if the line has positive orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns True for lines\n\n\n\n\n\n\n\ncurves.Line.slope()\nGet the slope of the line.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nSlope of the line (dy/dx)\n\n\n\n\n\n\n\n\n\ncurves.Ray(base, angle=None)\nA semi-infinite ray in the complex plane.\nA ray starts at a base point and extends infinitely in a given direction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbase\ncomplex or juliacall.AnyValue\nStarting point of the ray or Julia Ray object to wrap\nrequired\n\n\nangle\nfloat\nAngle of the ray direction in radians\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbase\ncomplex\nStarting point of the ray\n\n\nangle\nfloat\nAngle of the ray direction\n\n\n\n\n\n\n&gt;&gt;&gt; # Ray from origin at 45 degrees\n&gt;&gt;&gt; ray = Ray(0, np.pi/4)\n\n\n\n\ncurves.Segment(a, b=None)\nA line segment in the complex plane.\nA segment is a finite portion of a line connecting two endpoints.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex or juliacall.AnyValue\nFirst endpoint or Julia Segment object to wrap\nrequired\n\n\nb\ncomplex\nSecond endpoint (if a is first endpoint)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfirst\ncomplex\nFirst endpoint of the segment\n\n\nlast\ncomplex\nLast endpoint of the segment\n\n\n\n\n\n\n&gt;&gt;&gt; # Segment from origin to (1,1)\n&gt;&gt;&gt; seg = Segment(0, 1+1j)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the segment with respect to the origin.\n\n\n\n\n\ncurves.Segment.inv()\nCompute the inversion of the segment with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArc, Ray, or Segment\nThe type depends on the geometry after inversion\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrap_jl_curve\nWrap a Julia curve object in the appropriate Python class.\n\n\n\n\n\ncurves.wrap_jl_curve(jul)\nWrap a Julia curve object in the appropriate Python class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njul\njuliacall.AnyValue\nA Julia curve object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCurve\nThe appropriate Python curve wrapper (Circle, Arc, Line, Segment, Ray, etc.)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a Julia object or not a recognized curve type"
  },
  {
    "objectID": "reference/curves.html#attributes",
    "href": "reference/curves.html#attributes",
    "title": "curves",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nunitcircle\nUnit circle centered at the origin."
  },
  {
    "objectID": "reference/curves.html#classes",
    "href": "reference/curves.html#classes",
    "title": "curves",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nArc\nA circular arc in the complex plane.\n\n\nCircle\nA circle in the complex plane.\n\n\nClosedCurve\nA closed parametric curve in the complex plane.\n\n\nCurve\nA general parametric curve in the complex plane.\n\n\nJuliaCurve\nBase class for wrapping Julia curve objects from ComplexRegions.jl.\n\n\nLine\nAn infinite straight line in the complex plane.\n\n\nRay\nA semi-infinite ray in the complex plane.\n\n\nSegment\nA line segment in the complex plane.\n\n\n\n\n\ncurves.Arc(a, b=None, c=None)\nA circular arc in the complex plane.\nAn arc is a portion of a circle between two points.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex, Circle, or juliacall.AnyValue\nStart point, circle, or Julia Arc object to wrap\nrequired\n\n\nb\ncomplex\nEnd point (if a is start point)\nNone\n\n\nc\ncomplex\nCenter point (if constructing from start, end, center)\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncircle\nCircle or Segment\nThe underlying circle (or degenerate segment)\n\n\nstart\nfloat\nStarting parameter on the circle\n\n\ndelta\nfloat\nParameter range of the arc\n\n\n\n\n\n\n&gt;&gt;&gt; # Quarter circle arc from 1 to i around origin\n&gt;&gt;&gt; arc = Arc(1, 1j, 0)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the arc with respect to the origin.\n\n\n\n\n\ncurves.Arc.inv()\nCompute the inversion of the arc with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArc, Ray, or Segment\nThe type depends on the geometry after inversion\n\n\n\n\n\n\n\n\n\ncurves.Circle(a, b=None, c=None, ccw=True)\nA circle in the complex plane.\nCircles can be constructed in several ways: - From center and radius - From three points on the circle - From a Julia Circle object\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex or juliacall.AnyValue\nCenter point, first point on circle, or Julia Circle object\nrequired\n\n\nb\nfloat or complex\nRadius (if a is center) or second point on circle\nNone\n\n\nc\ncomplex\nThird point on circle (if constructing from three points)\nNone\n\n\nccw\nbool\nWhether the circle has counterclockwise orientation, default True\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncenter\ncomplex\nCenter of the circle\n\n\nradius\nfloat\nRadius of the circle\n\n\nccw\nbool\nWhether the circle has counterclockwise orientation\n\n\n\n\n\n\n&gt;&gt;&gt; # Unit circle at origin\n&gt;&gt;&gt; circle1 = Circle(0, 1)\n&gt;&gt;&gt; # Circle from center and radius with clockwise orientation\n&gt;&gt;&gt; circle2 = Circle(1+1j, 2, ccw=False)\n&gt;&gt;&gt; # Circle through three points\n&gt;&gt;&gt; circle3 = Circle(1, 1j, -1)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the circle with respect to the origin.\n\n\nisfinite\nCheck if the circle is finite.\n\n\nispositive\nCheck if the circle has positive (counterclockwise) orientation.\n\n\n\n\n\ncurves.Circle.inv()\nCompute the inversion of the circle with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCircle or Line\nCircle if the original circle doesn’t pass through the origin, Line if it does\n\n\n\n\n\n\n\ncurves.Circle.isfinite()\nCheck if the circle is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns True for circles\n\n\n\n\n\n\n\ncurves.Circle.ispositive()\nCheck if the circle has positive (counterclockwise) orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if counterclockwise, False if clockwise\n\n\n\n\n\n\n\n\n\ncurves.ClosedCurve(point, tangent=None, domain=(0.0, 1.0))\nA closed parametric curve in the complex plane.\nThis class represents a closed curve that forms a Jordan curve, enabling computation of winding numbers and interior/exterior tests.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npoint\ncallable or juliacall.AnyValue\nEither a function that maps parameter values to complex points, or a Julia closed curve object to wrap\nrequired\n\n\ntangent\ncallable\nFunction that maps parameter values to tangent vectors\nNone\n\n\ndomain\ntuple of float\nParameter domain as (start, end), default is (0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n&gt;&gt;&gt; # Create a closed curve (unit circle)\n&gt;&gt;&gt; point = lambda t: np.exp(2j * np.pi * t)\n&gt;&gt;&gt; tangent = lambda t: 2j * np.pi * np.exp(2j * np.pi * t)\n&gt;&gt;&gt; curve = ClosedCurve(point, tangent)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nhasinside\nCheck if point z is in the interior of the closed curve.\n\n\nwinding\nCompute the winding number of the curve around point z.\n\n\n\n\n\ncurves.ClosedCurve.hasinside(z)\nCheck if point z is in the interior of the closed curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is in the interior, False otherwise\n\n\n\n\n\n\n\ncurves.ClosedCurve.winding(z)\nCompute the winding number of the curve around point z.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint around which to compute winding number\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nWinding number (positive for counterclockwise orientation)\n\n\n\n\n\n\n\n\n\ncurves.Curve(point, tangent=None, domain=(0.0, 1.0))\nA general parametric curve in the complex plane.\nThis class represents a curve defined by a point function and optional tangent function over a parameter domain.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npoint\ncallable or juliacall.AnyValue\nEither a function that maps parameter values to complex points, or a Julia curve object to wrap\nrequired\n\n\ntangent\ncallable\nFunction that maps parameter values to tangent vectors\nNone\n\n\ndomain\ntuple of float\nParameter domain as (start, end), default is (0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n&gt;&gt;&gt; # Create a curve from a function\n&gt;&gt;&gt; curve = Curve(lambda t: t + 1j*t**2, lambda t: 1 + 2j*t)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the curve with respect to the origin.\n\n\n\n\n\ncurves.Curve.inv()\nCompute the inversion of the curve with respect to the origin.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCurve\nInverted curve\n\n\n\n\n\n\n\n\n\ncurves.JuliaCurve(julia_obj)\nBase class for wrapping Julia curve objects from ComplexRegions.jl.\nThis class provides a Python interface to Julia curve objects, handling the conversion between Python and Julia types and providing access to geometric operations on curves.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njulia_obj\njuliacall.AnyValue\nA Julia curve object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\njulia\njuliacall.AnyValue\nThe underlying Julia curve object\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\narclength\nCompute the arc length of the curve.\n\n\narg\nFind the parameter value corresponding to point z on the curve.\n\n\nclosest\nFind the closest point on the curve to z.\n\n\nconj\nReturn the complex conjugate of the curve.\n\n\ndist\nCompute the distance from point z to the curve.\n\n\nget\nGet a field from the underlying Julia object.\n\n\nintersect\nFind intersection points with another curve.\n\n\ninv\nCompute the inversion of the curve with respect to the origin.\n\n\nisapprox\nCheck if this curve is approximately equal to another.\n\n\nisfinite\nCheck if the curve has finite length.\n\n\nisleft\nCheck if point z is to the left of the curve.\n\n\nispositive\nCheck if the curve has positive orientation.\n\n\nisreal\nCheck if the curve lies on the real axis.\n\n\nisright\nCheck if point z is to the right of the curve.\n\n\nnormal\nCompute the normal at parameter t.\n\n\npoint\nEvaluate the curve at parameter value t.\n\n\nreflect\nReflect point z across the curve.\n\n\nreverse\nReturn the curve with reversed orientation.\n\n\ntangent\nCompute the tangent at parameter t.\n\n\nunittangent\nCompute the unit tangent at parameter t.\n\n\n\n\n\ncurves.JuliaCurve.arclength()\nCompute the arc length of the curve.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTotal arc length of the curve\n\n\n\n\n\n\n\ncurves.JuliaCurve.arg(z)\nFind the parameter value corresponding to point z on the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to locate on the curve\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat or None\nParameter value if z is on the curve, None otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.closest(z)\nFind the closest point on the curve to z.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nClosest point on the curve to z\n\n\n\n\n\n\n\ncurves.JuliaCurve.conj()\nReturn the complex conjugate of the curve.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nComplex conjugate of this curve\n\n\n\n\n\n\n\ncurves.JuliaCurve.dist(z)\nCompute the distance from point z to the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nReference point\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDistance from z to the closest point on the curve\n\n\n\n\n\n\n\ncurves.JuliaCurve.get(field)\nGet a field from the underlying Julia object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfield\nstr\nName of the field to retrieve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe value of the requested field\n\n\n\n\n\n\n\ncurves.JuliaCurve.intersect(other)\nFind intersection points with another curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaCurve\nAnother curve to intersect with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnumpy.ndarray or JuliaCurve\nArray of intersection points, or a curve if the intersection is a continuous curve segment\n\n\n\n\n\n\n\ncurves.JuliaCurve.inv()\nCompute the inversion of the curve with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njuliacall.AnyValue\nJulia object representing the inverted curve\n\n\n\n\n\n\nThis method returns a raw Julia object. Subclasses should override this method to return properly wrapped Python objects.\n\n\n\n\ncurves.JuliaCurve.isapprox(other)\nCheck if this curve is approximately equal to another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaCurve\nAnother curve to compare with\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if curves are approximately equal, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isfinite()\nCheck if the curve has finite length.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the curve is finite, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isleft(z)\nCheck if point z is to the left of the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is to the left of the curve, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.ispositive()\nCheck if the curve has positive orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if positively oriented, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isreal()\nCheck if the curve lies on the real axis.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the curve is real, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.isright(z)\nCheck if point z is to the right of the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is to the right of the curve, False otherwise\n\n\n\n\n\n\n\ncurves.JuliaCurve.normal(t)\nCompute the normal at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nNormal at parameter t\n\n\n\n\n\n\n\ncurves.JuliaCurve.point(t)\nEvaluate the curve at parameter value t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, typically in [0, 1]\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nPoint on the curve at parameter t\n\n\n\n\n\n\n\ncurves.JuliaCurve.reflect(z)\nReflect point z across the curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to reflect\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nReflected point\n\n\n\n\n\n\n\ncurves.JuliaCurve.reverse()\nReturn the curve with reversed orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaCurve\nCurve with reversed orientation\n\n\n\n\n\n\n\ncurves.JuliaCurve.tangent(t=0.0)\nCompute the tangent at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nTangent at parameter t\n\n\n\n\n\n\n\ncurves.JuliaCurve.unittangent(t=0.0)\nCompute the unit tangent at parameter t.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nParameter value, default is 0\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncomplex\nUnit tangent at parameter t\n\n\n\n\n\n\n\n\n\ncurves.Line(a, b=None, direction=None)\nAn infinite straight line in the complex plane.\nA line can be constructed from two points, or from a point and a direction. Lines have infinite arc length and are always considered to have positive orientation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex or juliacall.AnyValue\nEither a point on the line, or a Julia Line object to wrap\nrequired\n\n\nb\ncomplex\nSecond point on the line (if constructing from two points)\nNone\n\n\ndirection\ncomplex\nDirection vector of the line (if constructing from point and direction)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbase\ncomplex\nA base point on the line\n\n\ndirection\ncomplex\nDirection vector of the line\n\n\n\n\n\n\n&gt;&gt;&gt; # Line through two points\n&gt;&gt;&gt; line1 = Line(0, 1+1j)\n&gt;&gt;&gt; # Line through origin with given direction\n&gt;&gt;&gt; line2 = Line(0, direction=1+1j)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nangle\nGet the angle of the line’s direction vector.\n\n\narclength\nReturn infinite arc length for lines.\n\n\ninv\nCompute the inversion of the line with respect to the origin.\n\n\nisfinite\nCheck if the line is finite.\n\n\nispositive\nCheck if the line has positive orientation.\n\n\nslope\nGet the slope of the line.\n\n\n\n\n\ncurves.Line.angle()\nGet the angle of the line’s direction vector.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nAngle in radians\n\n\n\n\n\n\n\ncurves.Line.arclength()\nReturn infinite arc length for lines.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nAlways returns numpy.inf\n\n\n\n\n\n\n\ncurves.Line.inv()\nCompute the inversion of the line with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCircle or Line\nCircle if the line doesn’t pass through the origin, Line otherwise\n\n\n\n\n\n\n\ncurves.Line.isfinite()\nCheck if the line is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns False for lines\n\n\n\n\n\n\n\ncurves.Line.ispositive()\nCheck if the line has positive orientation.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns True for lines\n\n\n\n\n\n\n\ncurves.Line.slope()\nGet the slope of the line.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nSlope of the line (dy/dx)\n\n\n\n\n\n\n\n\n\ncurves.Ray(base, angle=None)\nA semi-infinite ray in the complex plane.\nA ray starts at a base point and extends infinitely in a given direction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbase\ncomplex or juliacall.AnyValue\nStarting point of the ray or Julia Ray object to wrap\nrequired\n\n\nangle\nfloat\nAngle of the ray direction in radians\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbase\ncomplex\nStarting point of the ray\n\n\nangle\nfloat\nAngle of the ray direction\n\n\n\n\n\n\n&gt;&gt;&gt; # Ray from origin at 45 degrees\n&gt;&gt;&gt; ray = Ray(0, np.pi/4)\n\n\n\n\ncurves.Segment(a, b=None)\nA line segment in the complex plane.\nA segment is a finite portion of a line connecting two endpoints.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\ncomplex or juliacall.AnyValue\nFirst endpoint or Julia Segment object to wrap\nrequired\n\n\nb\ncomplex\nSecond endpoint (if a is first endpoint)\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfirst\ncomplex\nFirst endpoint of the segment\n\n\nlast\ncomplex\nLast endpoint of the segment\n\n\n\n\n\n\n&gt;&gt;&gt; # Segment from origin to (1,1)\n&gt;&gt;&gt; seg = Segment(0, 1+1j)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninv\nCompute the inversion of the segment with respect to the origin.\n\n\n\n\n\ncurves.Segment.inv()\nCompute the inversion of the segment with respect to the origin.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArc, Ray, or Segment\nThe type depends on the geometry after inversion"
  },
  {
    "objectID": "reference/curves.html#functions",
    "href": "reference/curves.html#functions",
    "title": "curves",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nwrap_jl_curve\nWrap a Julia curve object in the appropriate Python class.\n\n\n\n\n\ncurves.wrap_jl_curve(jul)\nWrap a Julia curve object in the appropriate Python class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njul\njuliacall.AnyValue\nA Julia curve object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCurve\nThe appropriate Python curve wrapper (Circle, Arc, Line, Segment, Ray, etc.)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a Julia object or not a recognized curve type"
  },
  {
    "objectID": "reference/mobius.html",
    "href": "reference/mobius.html",
    "title": "mobius",
    "section": "",
    "text": "mobius\nMöbius transformation class for the cxregions package.\n\n\n\n\n\nName\nDescription\n\n\n\n\nMobius\nRepresentation of a Möbius or bilinear transformation.\n\n\n\n\n\nmobius.Mobius(*args)\nRepresentation of a Möbius or bilinear transformation.\nA Möbius transformation is a function of the form f(z) = (az + b) / (cz + d).\n\n\n\n\n\nName\nDescription\n\n\n\n\ncoeff\nReturn the coefficients [a, b, c, d] of the Möbius transformation.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompose\nCompose two Möbius transformations.\n\n\ninv\nReturn the inverse Möbius transformation.\n\n\n\n\n\nmobius.Mobius.compose(other)\nCompose two Möbius transformations.\n\n\n\nmobius.Mobius.inv()\nReturn the inverse Möbius transformation."
  },
  {
    "objectID": "reference/mobius.html#classes",
    "href": "reference/mobius.html#classes",
    "title": "mobius",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nMobius\nRepresentation of a Möbius or bilinear transformation.\n\n\n\n\n\nmobius.Mobius(*args)\nRepresentation of a Möbius or bilinear transformation.\nA Möbius transformation is a function of the form f(z) = (az + b) / (cz + d).\n\n\n\n\n\nName\nDescription\n\n\n\n\ncoeff\nReturn the coefficients [a, b, c, d] of the Möbius transformation.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompose\nCompose two Möbius transformations.\n\n\ninv\nReturn the inverse Möbius transformation.\n\n\n\n\n\nmobius.Mobius.compose(other)\nCompose two Möbius transformations.\n\n\n\nmobius.Mobius.inv()\nReturn the inverse Möbius transformation."
  },
  {
    "objectID": "reference/regions.html",
    "href": "reference/regions.html",
    "title": "regions",
    "section": "",
    "text": "regions\nRegion classes for the cxregions package.\nThis module contains all region-related classes including the base JuliaRegion class and specific region types like Interior1CRegion, Exterior1CRegion, and Annulus.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlefthalfplane\nLeft half-plane region (Re(z) &lt; 0).\n\n\nlowerhalfplane\nLower half-plane region (Im(z) &lt; 0).\n\n\nrighthalfplane\nRight half-plane region (Re(z) &gt; 0).\n\n\nunitdisk\nUnit disk region (|z| &lt; 1).\n\n\nupperhalfplane\nUpper half-plane region (Im(z) &gt; 0).\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nAnnulus\nAn annulus (ring-shaped region) between two circles.\n\n\nExterior1CRegion\nSimply connected exterior region.\n\n\nExteriorRegion\nExterior region with multiple inner boundaries.\n\n\nInterior1CRegion\nSimply connected interior region.\n\n\nInteriorConnectedRegion\nMultiply connected interior region.\n\n\nJuliaRegion\nBase class for wrapping Julia region objects from ComplexRegions.jl.\n\n\n\n\n\nregions.Annulus(outer, inner=None, center=0j)\nAn annulus (ring-shaped region) between two circles.\nThis represents the region between an inner and outer circle.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nouter\nfloat, Circle, or juliacall.AnyValue\nOuter radius, outer circle, or Julia Annulus object\nrequired\n\n\ninner\nfloat or Circle\nInner radius or inner circle\nNone\n\n\ncenter\ncomplex\nCenter point (if constructing from radii), default is 0\n0j\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ninner\nCircle\nInner boundary circle\n\n\nouter\nCircle\nOuter boundary circle\n\n\n\n\n\n\n&gt;&gt;&gt; # Annulus from radii\n&gt;&gt;&gt; annulus1 = Annulus(2, 1, center=0)\n&gt;&gt;&gt; # Annulus from circles\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; inner_circle = Circle(0, 1)\n&gt;&gt;&gt; outer_circle = Circle(0, 2)\n&gt;&gt;&gt; annulus2 = Annulus(outer_circle, inner_circle)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the annulus is finite.\n\n\nmodulus\nCompute the modulus of the annulus.\n\n\n\n\n\nregions.Annulus.isfinite()\nCheck if the annulus is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns True for annuli\n\n\n\n\n\n\n\nregions.Annulus.modulus()\nCompute the modulus of the annulus.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nThe modulus (related to the ratio of radii)\n\n\n\n\n\n\n\n\n\nregions.Exterior1CRegion(boundary)\nSimply connected exterior region.\nThis represents the region outside a single closed curve, extending to infinity.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboundary\nClosedCurve, ClosedPath, or juliacall.AnyValue\nThe boundary curve of the region\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nboundary\nClosedCurve or ClosedPath\nThe boundary curve of the region\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; exterior = Exterior1CRegion(circle)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.Exterior1CRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the boundary is finite, False otherwise\n\n\n\n\n\n\n\n\n\nregions.ExteriorRegion(inner)\nExterior region with multiple inner boundaries.\nThis represents the region outside multiple closed curves, extending to infinity.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninner\nlist of ClosedCurve/ClosedPath or juliacall.AnyValue\nThe inner boundary curves\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ninner\nlist of ClosedCurve/ClosedPath\nThe inner boundary curves\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle1 = Circle(0, 1)\n&gt;&gt;&gt; circle2 = Circle(3, 0.5)\n&gt;&gt;&gt; exterior = ExteriorRegion([circle1, circle2])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.ExteriorRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns False for exterior regions\n\n\n\n\n\n\n\n\n\nregions.Interior1CRegion(boundary)\nSimply connected interior region.\nThis represents the region inside a single closed curve.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboundary\nClosedCurve, ClosedPath, or juliacall.AnyValue\nThe boundary curve of the region\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nboundary\nClosedCurve or ClosedPath\nThe boundary curve of the region\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; interior = Interior1CRegion(circle)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.Interior1CRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the boundary is finite, False otherwise\n\n\n\n\n\n\n\n\n\nregions.InteriorConnectedRegion(outer, inner=[])\nMultiply connected interior region.\nThis represents the region inside an outer boundary but outside inner boundaries.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nouter\nClosedCurve, ClosedPath, or juliacall.AnyValue\nThe outer boundary curve\nrequired\n\n\ninner\nlist of ClosedCurve/ClosedPath\nThe inner boundary curves (holes)\n[]\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nouter\nClosedCurve or ClosedPath\nThe outer boundary curve\n\n\ninner\nlist of ClosedCurve/ClosedPath\nThe inner boundary curves\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; outer_circle = Circle(0, 2)\n&gt;&gt;&gt; inner_circle = Circle(0, 1)\n&gt;&gt;&gt; region = InteriorConnectedRegion(outer_circle, [inner_circle])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.InteriorConnectedRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if all boundaries are finite, False otherwise\n\n\n\n\n\n\n\n\n\nregions.JuliaRegion(julia_obj)\nBase class for wrapping Julia region objects from ComplexRegions.jl.\nThis class provides a Python interface to Julia region objects, which represent areas in the complex plane bounded by curves.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njulia_obj\njuliacall.AnyValue\nA Julia region object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\njulia\njuliacall.AnyValue\nThe underlying Julia region object\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncontains\nCheck if a point is contained in the region.\n\n\nget\nGet a field from the underlying Julia object.\n\n\ninnerboundary\nGet the inner boundary curves of the region.\n\n\nintersect\nCompute the intersection of this region with another.\n\n\nouterboundary\nGet the outer boundary curves of the region.\n\n\nunion\nCompute the union of this region with another.\n\n\n\n\n\nregions.JuliaRegion.contains(z=None)\nCheck if a point is contained in the region.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test for containment\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is in the region, False otherwise\n\n\n\n\n\n\n\nregions.JuliaRegion.get(field)\nGet a field from the underlying Julia object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfield\nstr\nName of the field to retrieve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe value of the requested field\n\n\n\n\n\n\n\nregions.JuliaRegion.innerboundary()\nGet the inner boundary curves of the region.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath or list of JuliaPath\nInner boundary curve(s) of the region\n\n\n\n\n\n\n\nregions.JuliaRegion.intersect(other)\nCompute the intersection of this region with another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaRegion\nAnother region to intersect with\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaRegion\nIntersection of the two regions\n\n\n\n\n\n\n\nregions.JuliaRegion.outerboundary()\nGet the outer boundary curves of the region.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath or list of JuliaPath\nOuter boundary curve(s) of the region\n\n\n\n\n\n\n\nregions.JuliaRegion.union(other)\nCompute the union of this region with another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaRegion\nAnother region to union with\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaRegion\nUnion of the two regions\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nJordan\nConstruct a Jordan curve from a ClosedPath or ClosedCurve object.\n\n\nbetween\nConstruct the region between two closed curves.\n\n\ndisk\nConstruct a disk as an interior region.\n\n\nexterior\nConstruct the exterior region of a closed curve.\n\n\nget_julia\nExtract the Julia object from a Python wrapper.\n\n\nhalfplane\nConstruct a half-plane as an interior region from a Line.\n\n\ninterior\nConstruct the interior region of a closed curve.\n\n\nwrap_jl_region\nWrap a Julia region object in the appropriate Python class.\n\n\n\n\n\nregions.Jordan(c)\nConstruct a Jordan curve from a ClosedPath or ClosedCurve object.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nc\nClosedPath, ClosedCurve, or juliacall.AnyValue\nA closed curve or path object\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nClosedPath or ClosedCurve\nThe input object if already a Jordan curve, or wrapped appropriately\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a valid closed curve or path\n\n\n\n\n\n\n\nregions.between(curve1, curve2)\nConstruct the region between two closed curves.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurve1\nClosedCurve or ClosedPath\nFirst boundary curve\nrequired\n\n\ncurve2\nClosedCurve or ClosedPath\nSecond boundary curve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInteriorConnectedRegion\nRegion between the two curves\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; outer = Circle(0, 2)\n&gt;&gt;&gt; inner = Circle(0, 1)\n&gt;&gt;&gt; region = between(outer, inner)\n\n\n\n\nregions.disk(center, radius)\nConstruct a disk as an interior region.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\ncomplex\nCenter of the disk\nrequired\n\n\nradius\nfloat\nRadius of the disk\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nDisk region\n\n\n\n\n\n\n&gt;&gt;&gt; disk_region = disk(1+1j, 2)\n\n\n\n\nregions.exterior(curve)\nConstruct the exterior region of a closed curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurve\nClosedCurve or ClosedPath\nBoundary curve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nExterior1CRegion\nExterior region of the curve\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; region = exterior(circle)\n\n\n\n\nregions.get_julia(p)\nExtract the Julia object from a Python wrapper.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\nJuliaCurve, JuliaPath, or other\nPython wrapper object or raw Julia object\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njuliacall.AnyValue or other\nThe underlying Julia object, or the input if not a wrapper\n\n\n\n\n\n\n\nregions.halfplane(l)\nConstruct a half-plane as an interior region from a Line.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nl\nLine\nLine that forms the boundary of the half-plane\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nHalf-plane region\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Line\n&gt;&gt;&gt; line = Line(0, direction=1)\n&gt;&gt;&gt; hp = halfplane(line)\n\n\n\n\nregions.interior(curve)\nConstruct the interior region of a closed curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurve\nClosedCurve or ClosedPath\nBoundary curve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nInterior region of the curve\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; region = interior(circle)\n\n\n\n\nregions.wrap_jl_region(jul)\nWrap a Julia region object in the appropriate Python class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njul\njuliacall.AnyValue\nA Julia region object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaRegion\nThe appropriate Python region wrapper\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a Julia object or not a recognized region type"
  },
  {
    "objectID": "reference/regions.html#attributes",
    "href": "reference/regions.html#attributes",
    "title": "regions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nlefthalfplane\nLeft half-plane region (Re(z) &lt; 0).\n\n\nlowerhalfplane\nLower half-plane region (Im(z) &lt; 0).\n\n\nrighthalfplane\nRight half-plane region (Re(z) &gt; 0).\n\n\nunitdisk\nUnit disk region (|z| &lt; 1).\n\n\nupperhalfplane\nUpper half-plane region (Im(z) &gt; 0)."
  },
  {
    "objectID": "reference/regions.html#classes",
    "href": "reference/regions.html#classes",
    "title": "regions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAnnulus\nAn annulus (ring-shaped region) between two circles.\n\n\nExterior1CRegion\nSimply connected exterior region.\n\n\nExteriorRegion\nExterior region with multiple inner boundaries.\n\n\nInterior1CRegion\nSimply connected interior region.\n\n\nInteriorConnectedRegion\nMultiply connected interior region.\n\n\nJuliaRegion\nBase class for wrapping Julia region objects from ComplexRegions.jl.\n\n\n\n\n\nregions.Annulus(outer, inner=None, center=0j)\nAn annulus (ring-shaped region) between two circles.\nThis represents the region between an inner and outer circle.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nouter\nfloat, Circle, or juliacall.AnyValue\nOuter radius, outer circle, or Julia Annulus object\nrequired\n\n\ninner\nfloat or Circle\nInner radius or inner circle\nNone\n\n\ncenter\ncomplex\nCenter point (if constructing from radii), default is 0\n0j\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ninner\nCircle\nInner boundary circle\n\n\nouter\nCircle\nOuter boundary circle\n\n\n\n\n\n\n&gt;&gt;&gt; # Annulus from radii\n&gt;&gt;&gt; annulus1 = Annulus(2, 1, center=0)\n&gt;&gt;&gt; # Annulus from circles\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; inner_circle = Circle(0, 1)\n&gt;&gt;&gt; outer_circle = Circle(0, 2)\n&gt;&gt;&gt; annulus2 = Annulus(outer_circle, inner_circle)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the annulus is finite.\n\n\nmodulus\nCompute the modulus of the annulus.\n\n\n\n\n\nregions.Annulus.isfinite()\nCheck if the annulus is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns True for annuli\n\n\n\n\n\n\n\nregions.Annulus.modulus()\nCompute the modulus of the annulus.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nThe modulus (related to the ratio of radii)\n\n\n\n\n\n\n\n\n\nregions.Exterior1CRegion(boundary)\nSimply connected exterior region.\nThis represents the region outside a single closed curve, extending to infinity.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboundary\nClosedCurve, ClosedPath, or juliacall.AnyValue\nThe boundary curve of the region\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nboundary\nClosedCurve or ClosedPath\nThe boundary curve of the region\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; exterior = Exterior1CRegion(circle)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.Exterior1CRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the boundary is finite, False otherwise\n\n\n\n\n\n\n\n\n\nregions.ExteriorRegion(inner)\nExterior region with multiple inner boundaries.\nThis represents the region outside multiple closed curves, extending to infinity.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninner\nlist of ClosedCurve/ClosedPath or juliacall.AnyValue\nThe inner boundary curves\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ninner\nlist of ClosedCurve/ClosedPath\nThe inner boundary curves\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle1 = Circle(0, 1)\n&gt;&gt;&gt; circle2 = Circle(3, 0.5)\n&gt;&gt;&gt; exterior = ExteriorRegion([circle1, circle2])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.ExteriorRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nAlways returns False for exterior regions\n\n\n\n\n\n\n\n\n\nregions.Interior1CRegion(boundary)\nSimply connected interior region.\nThis represents the region inside a single closed curve.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nboundary\nClosedCurve, ClosedPath, or juliacall.AnyValue\nThe boundary curve of the region\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nboundary\nClosedCurve or ClosedPath\nThe boundary curve of the region\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; interior = Interior1CRegion(circle)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.Interior1CRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if the boundary is finite, False otherwise\n\n\n\n\n\n\n\n\n\nregions.InteriorConnectedRegion(outer, inner=[])\nMultiply connected interior region.\nThis represents the region inside an outer boundary but outside inner boundaries.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nouter\nClosedCurve, ClosedPath, or juliacall.AnyValue\nThe outer boundary curve\nrequired\n\n\ninner\nlist of ClosedCurve/ClosedPath\nThe inner boundary curves (holes)\n[]\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nouter\nClosedCurve or ClosedPath\nThe outer boundary curve\n\n\ninner\nlist of ClosedCurve/ClosedPath\nThe inner boundary curves\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; outer_circle = Circle(0, 2)\n&gt;&gt;&gt; inner_circle = Circle(0, 1)\n&gt;&gt;&gt; region = InteriorConnectedRegion(outer_circle, [inner_circle])\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nisfinite\nCheck if the region is finite.\n\n\n\n\n\nregions.InteriorConnectedRegion.isfinite()\nCheck if the region is finite.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if all boundaries are finite, False otherwise\n\n\n\n\n\n\n\n\n\nregions.JuliaRegion(julia_obj)\nBase class for wrapping Julia region objects from ComplexRegions.jl.\nThis class provides a Python interface to Julia region objects, which represent areas in the complex plane bounded by curves.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njulia_obj\njuliacall.AnyValue\nA Julia region object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\njulia\njuliacall.AnyValue\nThe underlying Julia region object\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncontains\nCheck if a point is contained in the region.\n\n\nget\nGet a field from the underlying Julia object.\n\n\ninnerboundary\nGet the inner boundary curves of the region.\n\n\nintersect\nCompute the intersection of this region with another.\n\n\nouterboundary\nGet the outer boundary curves of the region.\n\n\nunion\nCompute the union of this region with another.\n\n\n\n\n\nregions.JuliaRegion.contains(z=None)\nCheck if a point is contained in the region.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\ncomplex\nPoint to test for containment\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if z is in the region, False otherwise\n\n\n\n\n\n\n\nregions.JuliaRegion.get(field)\nGet a field from the underlying Julia object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfield\nstr\nName of the field to retrieve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nAny\nThe value of the requested field\n\n\n\n\n\n\n\nregions.JuliaRegion.innerboundary()\nGet the inner boundary curves of the region.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath or list of JuliaPath\nInner boundary curve(s) of the region\n\n\n\n\n\n\n\nregions.JuliaRegion.intersect(other)\nCompute the intersection of this region with another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaRegion\nAnother region to intersect with\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaRegion\nIntersection of the two regions\n\n\n\n\n\n\n\nregions.JuliaRegion.outerboundary()\nGet the outer boundary curves of the region.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaPath or list of JuliaPath\nOuter boundary curve(s) of the region\n\n\n\n\n\n\n\nregions.JuliaRegion.union(other)\nCompute the union of this region with another.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nJuliaRegion\nAnother region to union with\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaRegion\nUnion of the two regions"
  },
  {
    "objectID": "reference/regions.html#functions",
    "href": "reference/regions.html#functions",
    "title": "regions",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nJordan\nConstruct a Jordan curve from a ClosedPath or ClosedCurve object.\n\n\nbetween\nConstruct the region between two closed curves.\n\n\ndisk\nConstruct a disk as an interior region.\n\n\nexterior\nConstruct the exterior region of a closed curve.\n\n\nget_julia\nExtract the Julia object from a Python wrapper.\n\n\nhalfplane\nConstruct a half-plane as an interior region from a Line.\n\n\ninterior\nConstruct the interior region of a closed curve.\n\n\nwrap_jl_region\nWrap a Julia region object in the appropriate Python class.\n\n\n\n\n\nregions.Jordan(c)\nConstruct a Jordan curve from a ClosedPath or ClosedCurve object.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nc\nClosedPath, ClosedCurve, or juliacall.AnyValue\nA closed curve or path object\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nClosedPath or ClosedCurve\nThe input object if already a Jordan curve, or wrapped appropriately\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a valid closed curve or path\n\n\n\n\n\n\n\nregions.between(curve1, curve2)\nConstruct the region between two closed curves.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurve1\nClosedCurve or ClosedPath\nFirst boundary curve\nrequired\n\n\ncurve2\nClosedCurve or ClosedPath\nSecond boundary curve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInteriorConnectedRegion\nRegion between the two curves\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; outer = Circle(0, 2)\n&gt;&gt;&gt; inner = Circle(0, 1)\n&gt;&gt;&gt; region = between(outer, inner)\n\n\n\n\nregions.disk(center, radius)\nConstruct a disk as an interior region.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncenter\ncomplex\nCenter of the disk\nrequired\n\n\nradius\nfloat\nRadius of the disk\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nDisk region\n\n\n\n\n\n\n&gt;&gt;&gt; disk_region = disk(1+1j, 2)\n\n\n\n\nregions.exterior(curve)\nConstruct the exterior region of a closed curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurve\nClosedCurve or ClosedPath\nBoundary curve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nExterior1CRegion\nExterior region of the curve\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; region = exterior(circle)\n\n\n\n\nregions.get_julia(p)\nExtract the Julia object from a Python wrapper.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\nJuliaCurve, JuliaPath, or other\nPython wrapper object or raw Julia object\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\njuliacall.AnyValue or other\nThe underlying Julia object, or the input if not a wrapper\n\n\n\n\n\n\n\nregions.halfplane(l)\nConstruct a half-plane as an interior region from a Line.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nl\nLine\nLine that forms the boundary of the half-plane\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nHalf-plane region\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Line\n&gt;&gt;&gt; line = Line(0, direction=1)\n&gt;&gt;&gt; hp = halfplane(line)\n\n\n\n\nregions.interior(curve)\nConstruct the interior region of a closed curve.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurve\nClosedCurve or ClosedPath\nBoundary curve\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nInterior1CRegion\nInterior region of the curve\n\n\n\n\n\n\n&gt;&gt;&gt; from cxregions.curves import Circle\n&gt;&gt;&gt; circle = Circle(0, 1)\n&gt;&gt;&gt; region = interior(circle)\n\n\n\n\nregions.wrap_jl_region(jul)\nWrap a Julia region object in the appropriate Python class.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njul\njuliacall.AnyValue\nA Julia region object from ComplexRegions.jl\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nJuliaRegion\nThe appropriate Python region wrapper\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the argument is not a Julia object or not a recognized region type"
  }
]